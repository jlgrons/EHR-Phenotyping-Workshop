})
phecap
})
temp <- do.call(rbind.data.frame, temp)
colnames(temp) <- outer(paste0("n=", c(50, 70, 90)),
c("PheCAP"), paste,
sep = ","
)
return(temp)
}
validate_phecap <- function(dat, surrogates, feature_selected, nsim, n.train = c(50, 70, 90)) {
surrogate_matrix <- sapply(surrogates, function(surrogate) {
rowSums(PheCAP::ehr_data[, surrogate$variable_names, drop = FALSE])
})
colnames(surrogate_matrix) <- sapply(surrogates, function(surrogate) {
paste0(surrogate$variable_names, collapse = "&")
})
# Orthogonalize.
label <- PheCAP::ehr_data$label
healthcare <- PheCAP::ehr_data$healthcare_utilization
other_features <- as.matrix(PheCAP::ehr_data[, setdiff(feature_selected$selected, c(colnames(surrogate_matrix))), drop = FALSE])
other_features <- qr.resid(qr(cbind(1.0, surrogate_matrix, healthcare)), other_features)
data_transformed <- data.frame(label = label,
surrogate_matrix,
healthcare_utilization = healthcare,
other_features)
temp <- parallel::mclapply(1:nsim, FUN = function(n) {
set.seed(1234 + n)
id.x <- lapply(n.train, function(n) sample(dat$patient_id, size = n))
id.y <- lapply(id.x, function(i) {
sample(dat$patient_id[which(!(dat$patient_id %in% i))], 46)
})
phecap <- sapply(1:3, function(i) {
mltools::auc_roc(
actuals = label[id.y[[i]]],
preds = linear_model_predict(
beta =
lasso_fit(
x = data_transformed[id.x[[i]], 2:ncol(data_transformed)],
y = label[id.x[[i]]],
family = "binomial",
tuning = "cv"
),
x = as.matrix(data_transformed[id.y[[i]], 2:ncol(data_transformed)]),
probability = TRUE
)
)
})
phecap
})
temp <- do.call(rbind.data.frame, temp)
colnames(temp) <- outer(paste0("n=", c(50, 70, 90)),
c("PheCAP"), paste,
sep = ","
)
return(temp)
}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
# Load helper functions.
source("../Rscripts/helper_function.R")
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
# Load helper functions.
source("../Rscripts/helper_function.R")
# If a package is installed, it will be loaded. If any
## are not, the missing package(s) will be installed
## from CRAN and then loaded.
## First specify the packages of interest
packages <- c(
"dplyr", "PheCAP", "glmnet", "randomForestSRC", "PheNorm",
"MAP", "pROC", "mltools", "data.table", "ggplot2", "parallel"
)
## Now load or install&load all
package.check <- lapply(
packages,
FUN = function(x) {
if (!require(x, character.only = TRUE)) {
install.packages(x, dependencies = TRUE)
library(x, character.only = TRUE)
}
}
)
data(ehr_data)
data <- PhecapData(PheCAP::ehr_data, "healthcare_utilization", "label", 75,
patient_id = "patient_id", seed = 123
)
# Data with non-missing labels
labeled_data <- ehr_data %>% dplyr::filter(!is.na(label))
# All Features
all_x <- ehr_data %>% dplyr::select(
starts_with("COD"), starts_with("NLP"),
starts_with("main"), healthcare_utilization
)
health_count <- ehr_data$healthcare_utilization
# Training Set
train_data <- ehr_data %>% dplyr::filter(patient_id %in% data$training_set)
train_x <- train_data %>%
dplyr::select(
starts_with("COD"), starts_with("NLP"),
starts_with("main"), healthcare_utilization
) %>%
as.matrix()
train_y <- train_data %>%
dplyr::select(label) %>%
pull()
# Testing Set
test_data <- ehr_data %>% dplyr::filter(patient_id %in% data$validation_set)
test_x <- test_data %>%
dplyr::select(
starts_with("COD"), starts_with("NLP"),
starts_with("main"), healthcare_utilization
) %>%
as.matrix()
test_y <- test_data %>%
dplyr::select(label) %>%
pull()
dim(train_x)
length(train_y)
dim(test_x)
length(test_y)
# Choose best lambda using CV
beta_lasso <- lasso_fit(
x = log(train_x + 1), y = train_y,
tuning = "cv", family = "binomial"
)
# Features Selected
names(beta_lasso[abs(beta_lasso) > 0])[-1]
# Fit Adaptive LASSO
beta_alasso <- adaptive_lasso_fit(
x = log(train_x + 1), y = train_y,
tuning = "cv", family = "binomial"
)
# ALASSO features selected
beta_alasso[!beta_alasso == 0][-1]
# LASSO features selected
beta_lasso[!beta_lasso==0][-1]
# Prediction on testing set (LASSO)
y_hat_lasso <- linear_model_predict(
beta = beta_lasso, x = log(test_x + 1),
probability = TRUE
)
# Prediction on testing set (ALASSO)
y_hat_alasso <- linear_model_predict(
beta = beta_alasso, x = log(test_x + 1),
probability = TRUE
)
roc_lasso <- roc(test_y, y_hat_lasso)
roc_alasso <- roc(test_y, y_hat_alasso)
# as expected alasso selects less features
plot_roc(list(roc_lasso, roc_alasso), legend = c("LASSO", "ALASSO"),
method_index = c(1,2))
roc_full_lasso <- get_roc(y_true = test_y, y_score = y_hat_lasso) %>% data.frame()
get_roc_parameter(0.1, roc_full_lasso)
roc_full_alasso <- get_roc(y_true = test_y, y_score = y_hat_alasso) %>% data.frame()
get_roc_parameter(0.1, roc_full_alasso)
auc_supervised <- validate_supervised(
dat = labeled_data, nsim = 600,
n.train = c(50, 70, 90)
)
plot_sims(auc_supervised, legend = c("LASSO", "ALASSO"), method_index = c(1,2))
# Random forest
model_rf <- rfsrc(y ~ ., data = data.frame(y = train_y, x = train_x))
y_hat_rf <- predict(model_rf,
newdata = data.frame(x = test_x)
)$predicted
roc_rf <- roc(test_y, y_hat_rf)
# SVM
model_svm <- SVMMaj::svmmaj(X = train_x, y = train_y)
y_hat_svm <- predict(model_svm, test_x)
roc_svm <- roc(test_y, y_hat_svm)
plot_roc(list(roc_lasso, roc_alasso, roc_rf, roc_svm),
legend = c("LASSO", "ALASSO", "Random Forest", "SVM"),
method_index = c(1,2,3,4))
save(list = ls(), file = "../module3/environment.RData")
# Load helper functions.
source("../Rscripts/helper_function.R")
# Load data.
load("../module3/environment.RData")
icd <- ehr_data %>%
filter(!is.na(label)) %>%
mutate(disease = factor(label)) %>%
ggplot(aes(x = log(main_ICD + 1))) +
geom_density(aes(color = disease)) +
theme(text = element_text(size = 15)) +
ggtitle("Density plot of the main ICD codes")
nlp <- ehr_data %>%
filter(!is.na(label)) %>%
mutate(disease = factor(label)) %>%
ggplot(aes(x = log(main_NLP + 1))) +
geom_density(aes(color = disease)) +
theme(text = element_text(size = 15)) +
ggtitle("Density plot of the main NLP codes")
figure <- ggarrange(icd, nlp, ncol = 2, nrow = 1, common.legend = TRUE)
figure
nonmissing_index <- which(!is.na(ehr_data$label))
y <- ehr_data$label[nonmissing_index]
sicd <- ehr_data$main_ICD[nonmissing_index]
snlp <- ehr_data$main_NLP[nonmissing_index]
roc_icd <- roc(y, log(sicd + 1))
roc_nlp <- roc(y, log(snlp + 1))
# Prepare features to be selected.
x <- data.matrix(ehr_data %>% select(starts_with("COD") | starts_with("NLP")))
plot_roc(list(roc_icd, roc_nlp), legend = c("ICD", "NLP"))
surrogates <- list(
PhecapSurrogate(
variable_names = "main_ICD",
lower_cutoff = 1, upper_cutoff = 10),
PhecapSurrogate(
variable_names = "main_NLP",
lower_cutoff = 1, upper_cutoff = 10))
feature_selected <- phecap_run_feature_extraction(data, surrogates)
feature_selected
phecap_lasso <- phecap_train_phenotyping_model(data, surrogates, feature_selected,
method = "lasso_cv")
phecap_lasso
# Get model predictions + ROC curve.
phenotype <- phecap_predict_phenotype(data, phecap_lasso)
y_hat_phecap <- phenotype[test_data$patient_id, "prediction"]
roc_phecap <- roc(test_y, y_hat_phecap)
plot_roc(list(roc_lasso, roc_alasso, roc_phecap),
legend = c("LASSO", "ALASSO", "PheCAP"),
method_index = c(1,2,5))
get_roc_parameter(0.1, roc_full_lasso)
get_roc_parameter(0.1, roc_full_alasso)
roc_full_phecap <- get_roc(y_true = test_y, y_score = y_hat_phecap) %>% data.frame()
get_roc_parameter(0.1, roc_full_phecap)
auc_phecap <- validate_phecap(dat = labeled_data,
surrogates = surrogates,
feature_selected = feature_selected,
nsim = 600,
n.train = c(50, 70, 90))
plot_sims(cbind(auc_supervised, auc_phecap),
legend = c("LASSO", "ALASSO", "PheCAP"),
method_index = c(1,2,5))
validate_supervised <- function(dat, nsim, ntrain = c(50, 70, 90)) {
temp <- parallel::mclapply(1:nsim, FUN = function(n) {
set.seed(1234 + n)
id.x <- lapply(n.train, function(n) sample(dat$patient_id, size = n))
id.y <- lapply(id.x, function(i) {
sample(dat$patient_id[which(!(dat$patient_id %in% i))], 46)
})
lasso <- sapply(1:3, function(i) {
auc_roc(
actuals = ehr_data[id.y[[i]], ]$label,
preds = linear_model_predict(
beta =
lasso_fit(
x = ehr_data[id.x[[i]], 3:ncol(ehr_data)],
y = ehr_data[id.x[[i]], ]$label,
family = "binomial",
tuning = "cv"
),
x = as.matrix(ehr_data[id.y[[i]], 3:ncol(ehr_data)]),
probability = TRUE
)
)
})
alasso <- sapply(1:3, function(i) {
auc_roc(
actuals = ehr_data[id.y[[i]], ]$label,
preds = linear_model_predict(
beta =
adaptive_lasso_fit(
x = ehr_data[id.x[[i]], 3:ncol(ehr_data)],
y = ehr_data[id.x[[i]], ]$label,
family = "binomial",
tuning = "cv"
),
x = as.matrix(ehr_data[id.y[[i]], 3:ncol(ehr_data)]),
probability = TRUE
)
)
})
c(lasso, alasso)
})
temp <- do.call(rbind.data.frame, temp)
colnames(temp) <- outer(paste0("n=", c(50, 70, 90)),
c("LASSO", "ALASSO"), paste,
sep = ","
)
return(temp)
}
validate_phecap <- function(dat, surrogates, feature_selected, nsim, ntrain = c(50, 70, 90)) {
surrogate_matrix <- sapply(surrogates, function(surrogate) {
rowSums(PheCAP::ehr_data[, surrogate$variable_names, drop = FALSE])
})
colnames(surrogate_matrix) <- sapply(surrogates, function(surrogate) {
paste0(surrogate$variable_names, collapse = "&")
})
# Orthogonalize.
label <- PheCAP::ehr_data$label
healthcare <- PheCAP::ehr_data$healthcare_utilization
other_features <- as.matrix(PheCAP::ehr_data[, setdiff(feature_selected$selected, c(colnames(surrogate_matrix))), drop = FALSE])
other_features <- qr.resid(qr(cbind(1.0, surrogate_matrix, healthcare)), other_features)
data_transformed <- data.frame(label = label,
surrogate_matrix,
healthcare_utilization = healthcare,
other_features)
temp <- parallel::mclapply(1:nsim, FUN = function(n) {
set.seed(1234 + n)
id.x <- lapply(n.train, function(n) sample(dat$patient_id, size = n))
id.y <- lapply(id.x, function(i) {
sample(dat$patient_id[which(!(dat$patient_id %in% i))], 46)
})
phecap <- sapply(1:3, function(i) {
mltools::auc_roc(
actuals = label[id.y[[i]]],
preds = linear_model_predict(
beta =
lasso_fit(
x = data_transformed[id.x[[i]], 2:ncol(data_transformed)],
y = label[id.x[[i]]],
family = "binomial",
tuning = "cv"
),
x = as.matrix(data_transformed[id.y[[i]], 2:ncol(data_transformed)]),
probability = TRUE
)
)
})
phecap
})
temp <- do.call(rbind.data.frame, temp)
colnames(temp) <- outer(paste0("n=", c(50, 70, 90)),
c("PheCAP"), paste,
sep = ","
)
return(temp)
}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
# Load helper functions.
source("../Rscripts/helper_function.R")
# If a package is installed, it will be loaded. If any
## are not, the missing package(s) will be installed
## from CRAN and then loaded.
## First specify the packages of interest
packages <- c(
"dplyr", "PheCAP", "glmnet", "randomForestSRC", "PheNorm",
"MAP", "pROC", "mltools", "data.table", "ggplot2", "parallel"
)
## Now load or install&load all
package.check <- lapply(
packages,
FUN = function(x) {
if (!require(x, character.only = TRUE)) {
install.packages(x, dependencies = TRUE)
library(x, character.only = TRUE)
}
}
)
data(ehr_data)
data <- PhecapData(PheCAP::ehr_data, "healthcare_utilization", "label", 75,
patient_id = "patient_id", seed = 123)
# Data with non-missing labels
labeled_data <- ehr_data %>% dplyr::filter(!is.na(label))
# All Features
all_x <- ehr_data %>% dplyr::select(starts_with("COD"), starts_with("NLP"),
starts_with("main"), healthcare_utilization)
health_count <- ehr_data$healthcare_utilization
# Training Set
train_data <- ehr_data %>% dplyr::filter(patient_id %in% data$training_set)
train_x <- train_data %>%
dplyr::select(starts_with("COD"), starts_with("NLP"),
starts_with("main"), healthcare_utilization) %>% as.matrix()
train_y <- train_data %>% dplyr::select(label) %>% pull()
# Testing Set
test_data <- ehr_data %>% dplyr::filter(patient_id %in% data$validation_set)
test_x <- test_data %>%
dplyr::select(starts_with("COD"), starts_with("NLP"),
starts_with("main"), healthcare_utilization) %>% as.matrix()
test_y <- test_data %>% dplyr::select(label) %>% pull()
dim(train_x)
dim(test_x)
length(train_y)
length(test_y)
# Choose best lambda using CV.
beta_lasso <- lasso_fit(x = log(train_x + 1),
y = train_y,
tuning = "cv",
family = "binomial")
# Features Selected.
names(beta_lasso[abs(beta_lasso) > 0])[-1]
# Fit Adaptive LASSO.
beta_alasso <- adaptive_lasso_fit(x = log(train_x + 1),
y = train_y,
tuning = "cv",
family = "binomial")
# ALASSO features selected.
beta_alasso[!beta_alasso == 0][-1]
# LASSO features selected.
beta_lasso[!beta_lasso==0][-1]
# Prediction on testing set (LASSO).
y_hat_lasso <- linear_model_predict(beta = beta_lasso,
x = log(test_x + 1),
probability = TRUE)
# Prediction on testing set (ALASSO).
y_hat_alasso <- linear_model_predict(beta = beta_alasso,
x = log(test_x + 1),
probability = TRUE)
roc_lasso <- roc(test_y, y_hat_lasso)
roc_alasso <- roc(test_y, y_hat_alasso)
plot_roc(list(roc_lasso, roc_alasso),
legend = c("LASSO", "ALASSO"),
method_index = c(1,2))
roc_full_lasso <- get_roc(y_true = test_y, y_score = y_hat_lasso) %>% data.frame()
get_roc_parameter(0.1, roc_full_lasso)
roc_full_alasso <- get_roc(y_true = test_y, y_score = y_hat_alasso) %>% data.frame()
get_roc_parameter(0.1, roc_full_alasso)
auc_supervised <- validate_supervised(dat = labeled_data, nsim = 600, ntrain = c(50, 70, 90))
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
# If a package is installed, it will be loaded. If any
## are not, the missing package(s) will be installed
## from CRAN and then loaded.
## First specify the packages of interest
packages <- c(
"dplyr", "PheCAP", "glmnet", "randomForestSRC", "PheNorm",
"MAP", "pROC", "mltools", "data.table", "ggplot2", "parallel"
)
## Now load or install&load all
package.check <- lapply(
packages,
FUN = function(x) {
if (!require(x, character.only = TRUE)) {
install.packages(x, dependencies = TRUE)
library(x, character.only = TRUE)
}
}
)
# load environment from example 1
load("../module4/environment.RData")
source("../Rscripts/helper_function.R")
# format slides nicely please
# COD + NLP + HU.
x <- log(ehr_data %>% select(starts_with("health") |
starts_with("COD") | starts_with("NLP")) + 1)
S <- log(ehr_data$main_ICD + ehr_data$main_NLP + 1)
# Step 1.
beta_step1 <- adaptive_lasso_fit(
y = S[], # surrogate
x = x[], # all X
family = "gaussian",
tuning = "ic"
)
# Linear predictor without intercept.
bhatx <- linear_model_predict(beta = beta_step1, x = as.matrix(x))
# Step 2.
step2 <- glm(
train_y ~ bhatx[train_data$patient_id] + S[train_data$patient_id],
family = "binomial"
)
beta_step2 <- coef(step2)
beta_step2
# Recover beta.
beta <- beta_step2[2] * beta_step1
# LASSO
names(beta_lasso[!beta_lasso == 0])[-1]
# ALASSO
names(beta_alasso[!beta_alasso == 0])[-1]
# PheCAP.
feature_selected
# Two Step.
names(beta[!beta == 0])[-1]
mu <- beta_step2[1] +
as.numeric(as.matrix(x[test_data$patient_id, ])
%*% beta[-1]) +
as.numeric(beta_step2[3] %*% S[test_data$patient_id])
# Expit.
y_hat_twostep <- plogis(mu)
roc_twostep <- roc(test_y, y_hat_twostep)
plot_roc(
list(roc_lasso, roc_alasso, roc_phecap, roc_twostep),
legend = c("LASSO", "ALASSO", "PheCAP", "Two-step"),
method_index = c(1,2,5,6)
)
auc_twostep <- validate_ss(
dat = labeled_data, nsim = 600,
n.train = c(50, 70, 90),
beta = beta_step1,
S = S,
x = x
)
auc_twostep <- validate_ss(
dat = labeled_data, nsim = 600,
ntrain = c(50, 70, 90),
beta = beta_step1,
S = S,
x = x
)
plot_sims(
cbind(auc_supervised, auc_phecap, auc_twostep),
legend = c("LASSO", "ALASSO", "PheCAP", "Two-step"),
method_index = c(1,2,5,6)
)
# Use untransformed data; MAP requires sparse matrix.
# Create sparse matrix for surrogates.
data_fit <- sparsify(
PheCAP::ehr_data %>%
select(main_ICD, main_NLP) %>%
rename(ICD = main_ICD) %>% data.table()
)
# Create sparse matrix for HU
note <- Matrix(
PheCAP::ehr_data$healthcare_utilization,
ncol = 1, sparse = TRUE
)
model_map <- MAP(mat = data_fit, note = note, full.output = TRUE)
y_hat_map <- model_map$scores[data$validation_set]
roc_map <- roc(test_y, y_hat_map)
plot_roc(
list(roc_lasso, roc_alasso, roc_phecap, roc_twostep, roc_map),
legend = c("LASSO", "ALASSO", "PheCAP", "Two-step", "MAP"),
method_index = c(1,2,5,6,7)
)
